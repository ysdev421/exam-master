import type { Question } from '../types';

export const questionDatabase: Record<string, Question[]> = {
  algorithm: [
    { id: 1, question: '時間計算量がO(n log n)のアルゴリズムはどれか？', answers: ['バブルソート', 'マージソート', '選択ソート', '挿入ソート'], correct: 1, explanation: 'マージソートは分割統治法を使用し、時間計算量はO(n log n)です。', diagram: 'merge-sort' },
    { id: 2, question: 'スタックのデータ構造の特徴は次のうちどれか？', answers: ['FIFO（先入先出）', 'LIFO（後入先出）', 'ランダムアクセス', '優先度付き'], correct: 1, explanation: 'スタックはLIFO（Last In First Out）で、最後に追加されたデータが最初に取り出されます。', diagram: 'stack' },
    { id: 3, question: 'キューのデータ構造の特徴は次のうちどれか？', answers: ['LIFO', 'FIFO（先入先出）', 'ツリー構造', 'グラフ構造'], correct: 1, explanation: 'キューはFIFO（First In First Out）で、最初に追加されたデータが最初に取り出されます。', diagram: 'queue' },
    { id: 4, question: 'バイナリサーチ（二分探索）の時間計算量は？', answers: ['O(n)', 'O(n log n)', 'O(log n)', 'O(1)'], correct: 2, explanation: '二分探索は毎回範囲を半分にするため、時間計算量はO(log n)です。ただしソート済み配列が前提です。', diagram: 'binary-search' },
    { id: 5, question: 'グラフの深さ優先探索（DFS）で使用するデータ構造は？', answers: ['キュー', 'スタック', 'ハッシュテーブル', 'ヒープ'], correct: 1, explanation: '深さ優先探索（DFS）ではスタックを使用します。幅優先探索（BFS）ではキューを使用します。', diagram: 'dfs' },
    { id: 6, question: 'ソート済みリストの線形探索の時間計算量は？', answers: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'], correct: 2, explanation: '線形探索は各要素を順番に調べるため、時間計算量はO(n)です。', diagram: 'linear-search' },
    { id: 7, question: 'ハッシュテーブルにおける「ハッシュ衝突」とは何か？', answers: ['異なるキーが同じハッシュ値になること', 'テーブルが満杯になること', 'キーが見つからないこと', 'メモリ不足'], correct: 0, explanation: 'ハッシュ衝突とは、異なるキーが同じハッシュ値にマップされることです。チェイニングや線形探査で対応します。', diagram: 'hash-collision' },
    { id: 8, question: 'クイックソートの平均時間計算量は？', answers: ['O(n)', 'O(n log n)', 'O(n²)', 'O(2^n)'], correct: 1, explanation: 'クイックソートの平均時間計算量はO(n log n)です。ただし最悪ケースではO(n²)になる可能性があります。', diagram: 'quicksort' },
    { id: 9, question: 'ツリー構造で、ある節点から根（ルート）までのパスの長さを何というか？', answers: ['深さ', '高さ', '幅', 'レベル'], correct: 0, explanation: '深さ（depth）はルートからその節点までのパスの長さです。高さ（height）は節点からリーフまでの最長パスです。', diagram: 'tree-depth' },
    { id: 10, question: 'バランス二分探索木（AVL木）の特徴は？', answers: ['常に完全二分木である', 'すべての葉が同じ深さ', '左右の部分木の高さが最大1差', 'すべてソート済み'], correct: 2, explanation: 'AVL木は自己平衡二分探索木で、左右の部分木の高さの差が最大1です。これにより検索の効率を保ちます。', diagram: 'avl-tree' },
    { id: 11, question: 'ダイクストラのアルゴリズムが求めるものは？', answers: ['最大流', '最短経路', 'スパニングツリー', '強連結成分'], correct: 1, explanation: 'ダイクストラのアルゴリズムはグラフの最短経路を求めます。非負の重みが前提です。', diagram: 'dijkstra' },
    { id: 12, question: 'キュー構造での enqueue 操作は？', answers: ['先頭から削除', '末尾に追加', '中央に挿入', 'ランダムアクセス'], correct: 1, explanation: 'enqueue はキューの末尾に要素を追加する操作です。dequeue は先頭から削除します。', diagram: 'queue-operation' },
  ],
  network: [
    { id: 1, question: 'OSI参照モデルで、IPが該当するのは第何層か？', answers: ['第2層', '第3層', '第4層', '第5層'], correct: 1, explanation: 'IP（インターネットプロトコル）はネットワーク層（第3層）に該当します。', diagram: 'osi-model' },
    { id: 2, question: 'TCP/IPモデルで、TCPが該当するレイヤーは？', answers: ['アプリケーション層', 'トランスポート層', 'インターネット層', 'リンク層'], correct: 1, explanation: 'TCP（Transmission Control Protocol）はトランスポート層（第4層）に属します。', diagram: 'tcp-ip-model' },
    { id: 3, question: 'UDPの特徴として正しいのは？', answers: ['接続を確立してから通信', '信頼性が高い', 'コネクションレス', '順序が必ず正確'], correct: 2, explanation: 'UDP（User Datagram Protocol）はコネクションレスで、信頼性は保証しませんが低遅延です。', diagram: 'udp-vs-tcp' },
    { id: 4, question: 'IPアドレスのクラスCの範囲は？', answers: ['0.0.0.0 ～ 127.255.255.255', '128.0.0.0 ～ 191.255.255.255', '192.0.0.0 ～ 223.255.255.255', '224.0.0.0 ～ 239.255.255.255'], correct: 2, explanation: 'クラスCのIPアドレスは192.0.0.0 ～ 223.255.255.255の範囲で、第1オクテットが192～223です。', diagram: 'ip-class' },
    { id: 5, question: 'プライベートIPアドレスの範囲として正しくないのは？', answers: ['10.0.0.0 ～ 10.255.255.255', '172.16.0.0 ～ 172.31.255.255', '192.168.0.0 ～ 192.168.255.255', '200.0.0.0 ～ 200.255.255.255'], correct: 3, explanation: 'プライベートIPアドレスは10.0.0.0, 172.16.0.0, 192.168.0.0の3つの範囲です。200.0.0.0はグローバルIPです。', diagram: 'private-ip' },
    { id: 6, question: 'サブネットマスク255.255.255.0は何を表すか？', answers: ['/8', '/16', '/24', '/32'], correct: 2, explanation: '255.255.255.0 は CIDR表記で /24 です。255は1が8個なので、8×3=24ビットがネットワーク部です。', diagram: 'subnet-mask' },
    { id: 7, question: 'DNSの役割として正しいのは？', answers: ['IPアドレスの割り当て', 'ドメイン名をIPアドレスに変換', 'ネットワーク接続の管理', 'セキュリティ認証'], correct: 1, explanation: 'DNS（Domain Name System）はドメイン名（例：google.com）をIPアドレス（例：142.251.46.102）に変換します。', diagram: 'dns' },
    { id: 8, question: 'HTTPSのSSL/TLSの役割は？', answers: ['データの圧縮', 'データの暗号化と認証', 'データの分割', 'ネットワーク接続'], correct: 1, explanation: 'SSL/TLSはHTTPSで使用され、データを暗号化し、サーバーの真正性を認証します。', diagram: 'https-tls' },
    { id: 9, question: 'ルーティングテーブルの役割は？', answers: ['MACアドレスの管理', 'パケットを適切なインターフェースに転送', 'ホスト名の解決', 'セッション管理'], correct: 1, explanation: 'ルーティングテーブルはIPアドレスのネットワーク部を基に、パケットを適切なインターフェースに転送します。', diagram: 'routing-table' },
    { id: 10, question: 'ARPの役割は？', answers: ['IPアドレスをドメイン名に変換', 'IPアドレスをMACアドレスに変換', 'ポート番号を割り当てる', 'ネットワークトポロジを検出'], correct: 1, explanation: 'ARP（Address Resolution Protocol）はIPアドレスをMACアドレスに変換します。同一LAN内での通信に必要です。', diagram: 'arp' },
    { id: 11, question: 'DHCP の役割として正しいのは？', answers: ['ドメイン名の解決', 'IPアドレスの自動割り当て', 'パケットの暗号化', 'ネットワーク監視'], correct: 1, explanation: 'DHCP（Dynamic Host Configuration Protocol）はIPアドレスをクライアントに自動的に割り当てます。', diagram: 'dhcp' },
    { id: 12, question: 'イーサネットのMACアドレスの長さは？', answers: ['32ビット', '48ビット', '64ビット', '128ビット'], correct: 1, explanation: 'MACアドレス（物理アドレス）は48ビット（6オクテット）の長さです。例：00-1A-2B-3C-4D-5E', diagram: 'mac-address' },
    { id: 13, question: 'CIDRの /24 は何を意味するか？', answers: ['24個のホストが使用可能', 'ネットワーク部が24ビット', 'パケットサイズが24', 'アドレスプレフィックスが24'], correct: 1, explanation: 'CIDR表記の /24 はネットワーク部が24ビット（サブネットマスク255.255.255.0）を意味します。', diagram: 'cidr' },
    { id: 14, question: 'インターネット層で使用されるプロトコルは？', answers: ['Ethernet', 'IP', 'TCP', 'HTTP'], correct: 1, explanation: 'IP（Internet Protocol）はインターネット層（第3層）で使用されます。', diagram: 'internet-layer' },
    { id: 15, question: 'FTP通信でデータ転送に使用される通常のポート番号は？', answers: ['21', '22', '80', '443'], correct: 0, explanation: 'FTPのコントロール接続はポート21を使用します。データ転送もポート20または高いポート番号を使用します。', diagram: 'ftp-port' },
  ],
  database: [
    { id: 1, question: 'リレーショナルデータベースで、重複する行を除去するSQLキーワードは？', answers: ['UNIQUE', 'DISTINCT', 'PRIMARY KEY', 'NOT NULL'], correct: 1, explanation: 'DISTINCT キーワードは SELECT ステートメントで使用され、重複する行を除去します。', diagram: 'distinct' },
    { id: 2, question: '外部キー（Foreign Key）の役割は？', answers: ['主キーを定義する', '複数テーブル間の関連を定義', '行を一意に識別する', 'インデックスを作成'], correct: 1, explanation: '外部キーは別のテーブルの主キーを参照し、テーブル間の参照整合性を保証します。', diagram: 'foreign-key' },
    { id: 3, question: '第3正規化（3NF）の条件として正しいのは？', answers: ['すべての列が主キーに完全従属', '推移従属がない', '部分従属がない', 'すべて'], correct: 1, explanation: '第3正規化（3NF）では推移従属を排除します。第2NF を満たしつつ、主キーでない属性が主キー以外の属性に従属しません。', diagram: '3nf' },
    { id: 4, question: 'SQLの INNER JOIN の結果は？', answers: ['左テーブルのすべてのデータ', '両テーブルに共通するデータ', '右テーブルのすべてのデータ', '両テーブル全部のデータ'], correct: 1, explanation: 'INNER JOIN は両テーブルに共通するデータだけを結果として返します。', diagram: 'inner-join' },
    { id: 5, question: 'トランザクションの ACID 特性で、D は何の頭文字か？', answers: ['Delay', 'Durability', 'Database', 'Directory'], correct: 1, explanation: 'ACID のD はDurability（永続性）です。コミット後のデータは障害時にも保証されます。', diagram: 'acid' },
    { id: 6, question: 'インデックスの利点として正しいのは？', answers: ['ディスク容量が増える', 'クエリのアクセス速度が上がる', 'INSERT/UPDATE の速度が上がる', 'テーブルサイズが小さくなる'], correct: 1, explanation: 'インデックスはクエリのアクセス速度を向上させますが、INSERT/UPDATE/DELETE は遅くなり、ディスク容量も増えます。', diagram: 'index' },
    { id: 7, question: 'ビュー（View）の特徴として正しいのは？', answers: ['実際にデータを保存する', '仮想的なテーブル', 'インデックスの一種', 'キャッシュ'], correct: 1, explanation: 'ビューは実際にはデータを保存せず、SELECT クエリに基づいた仮想的なテーブルです。', diagram: 'view' },
    { id: 8, question: 'SQL の GROUP BY 句の役割は？', answers: ['行をソートする', '重複を除去する', '指定した列でグループ化して集約する', 'テーブルを結合'], correct: 2, explanation: 'GROUP BY は指定した列でグループ化し、SUM, COUNT, AVG などの集約関数を適用します。', diagram: 'group-by' },
    { id: 9, question: 'デッドロックが発生する条件として正しいのは？', answers: ['ネットワークが遅い', '複数トランザクションが互いにリソースを待機', 'CPU が不足', 'メモリが満杯'], correct: 1, explanation: 'デッドロックは2つ以上のトランザクションが互いが保持するリソースを待機する状態です。', diagram: 'deadlock' },
    { id: 10, question: 'ノーマライゼーション（正規化）の目的として正しいのは？', answers: ['クエリ速度を上げる', 'データの重複を排除し整合性を保証', 'テーブル数を増やす', 'ディスク容量を削減'], correct: 1, explanation: '正規化はデータの重複を排除し、データベースの論理的な整合性と効率を向上させます。', diagram: 'normalization' },
    { id: 11, question: 'SQL の WHERE 句と HAVING 句の違いは？', answers: ['同じ意味', 'WHERE は個別行、HAVING は集約関数の結果に適用', 'HAVING は個別行', '処理順序が同じ'], correct: 1, explanation: 'WHERE は個別行に適用され、HAVING は GROUP BY による集約結果に適用されます。', diagram: 'where-vs-having' },
    { id: 12, question: 'SQLインジェクション対策として効果的なのは？', answers: ['データベースを大きくする', 'プリペアドステートメント使用', 'テーブルを分割', 'パスワード暗号化'], correct: 1, explanation: 'プリペアドステートメント（パラメータ化クエリ）はSQLインジェクション攻撃を防ぎます。', diagram: 'sql-injection' },
  ],
  security: [
    { id: 1, question: '公開鍵暗号で、秘密鍵を使うのは主に何の目的か？', answers: ['データの暗号化', 'デジタル署名の生成', 'データの圧縮', 'ハッシュ値の計算'], correct: 1, explanation: '秘密鍵はデジタル署名の生成と、公開鍵で暗号化されたデータの復号に使用されます。', diagram: 'public-key' },
    { id: 2, question: 'SSL/TLSハンドシェイクの目的は？', answers: ['ファイルの転送', 'サーバー認証と暗号化キー交換', 'ユーザー認証', 'ネットワーク接続'], correct: 1, explanation: 'SSL/TLSハンドシェイクはサーバーの真正性を認証し、共有の暗号化キーを交換します。', diagram: 'ssl-handshake' },
    { id: 3, question: 'パスワードハッシング関数の特徴として正しいのは？', answers: ['復号可能', '一方向関数', 'すべてのパスワードで同じ結果', '計算が高速'], correct: 1, explanation: 'ハッシング関数は一方向性があり、ハッシュからパスワードを復元できません。', diagram: 'password-hash' },
    { id: 4, question: 'ファイアウォールの役割として正しいのは？', answers: ['ウイルス除去', '通信パケットをフィルタリング', 'ディスク暗号化', 'ネットワーク圧縮'], correct: 1, explanation: 'ファイアウォールはネットワークトラフィックを監視・制御し、不正なアクセスを防ぎます。', diagram: 'firewall' },
    { id: 5, question: 'XSS（クロスサイトスクリプティング）の対策として有効なのは？', answers: ['HTTPSの使用', 'HTML エスケープ処理', 'ファイアウォール', 'VPN'], correct: 1, explanation: 'XSS対策としてHTML エスケープやHTMLサニタイズが有効です。ユーザー入力を検証・エスケープします。', diagram: 'xss' },
    { id: 6, question: '認証と認可の違いは？', answers: ['同じ意味', 'ユーザー確認と権限確認', 'パスワード設定と変更', '同じプロセス'], correct: 1, explanation: '認証（Authentication）はユーザーが本人であることを確認。認可（Authorization）はそのユーザーができることを制限します。', diagram: 'auth-vs-authz' },
    { id: 7, question: 'RSA暗号の安全性の根拠は？', answers: ['計算が高速', '素因数分解の困難性', 'キー長が長い', 'ランダム性'], correct: 1, explanation: 'RSA暗号は大きな数の素因数分解が困難であることに基づいています。', diagram: 'rsa' },
    { id: 8, question: 'CSRF（クロスサイトリクエストフォージェリ）対策として有効なのは？', answers: ['SSL/TLSの使用', 'CSRF トークン', 'ファイアウォール', 'VPN'], correct: 1, explanation: 'CSRF対策として、予測不可能なトークンをフォームに含め検証することが有効です。', diagram: 'csrf' },
    { id: 9, question: '多要素認証（MFA）の例として正しいのは？', answers: ['強力なパスワード', 'パスワード+生体認証', '複数のパスワード', 'アカウント番号'], correct: 1, explanation: '多要素認証は2種類以上の異なる認証方式を組み合わせます。パスワード+SMSコード、パスワード+指紋など。', diagram: 'mfa' },
    { id: 10, question: 'サイバー攻撃の「ゼロデイ攻撃」とは？', answers: ['最初の攻撃', '初日に報告される攻撃', 'ベンダーが未発見の脆弱性を突く攻撃', 'ランダム攻撃'], correct: 2, explanation: 'ゼロデイ攻撃はベンダーが脆弱性を知らない間に、その脆弱性を悪用する攻撃です。', diagram: 'zero-day' },
  ],
  programming: [
    { id: 1, question: 'オブジェクト指向プログラミングの四大要素は？', answers: ['順序、条件、反復、関数', 'クラス、オブジェクト、メッセージ、メソッド', 'ポインタ、配列、構造体、共用体', 'メモリ、CPU、ディスク、I/O'], correct: 1, explanation: 'オブジェクト指向の基本はクラス（設計図）とオブジェクト（実体）です。', diagram: 'oop' },
    { id: 2, question: 'コンパイル言語と比べた場合、インタプリタ言語の利点は？', answers: ['実行速度が速い', '開発効率が高い', 'メモリ使用量が少ない', 'セキュリティが高い'], correct: 1, explanation: 'インタプリタ言語は即座に実行できるため、開発効率が高く、テストループが短いです。', diagram: 'compiler-vs-interpreter' },
    { id: 3, question: '例外処理の目的は？', answers: ['プログラム高速化', 'エラー時の適切な対応と継続処理', 'メモリ削減', 'コード行数削減'], correct: 1, explanation: '例外処理はエラーを適切に処理し、プログラムの堅牢性を向上させます。', diagram: 'exception-handling' },
    { id: 4, question: '再帰関数とは？', answers: ['複数の引数を持つ関数', '関数が自分自身を呼び出す関数', '他の関数を呼び出す関数', 'クラスメソッド'], correct: 1, explanation: '再帰関数は自身を呼び出すことで、複雑な問題を分割して解きます。ベースケースがないと無限ループになります。', diagram: 'recursion' },
    { id: 5, question: 'メモリリークが発生する原因として正しいのは？', answers: ['ファイルを開きっぱなし', '動的割り当てメモリの未解放', 'グローバル変数使用', 'ループ処理'], correct: 1, explanation: 'メモリリークはdynamic memory allocationで確保したメモリを解放しないことで発生します。', diagram: 'memory-leak' },
    { id: 6, question: 'ポインタの役割として正しいのは？', answers: ['変数の値を保存', 'メモリアドレスを保存', '計算結果を保存', '関数を保存'], correct: 1, explanation: 'ポインタは変数のメモリアドレスを保存し、間接的にアクセスします。', diagram: 'pointer' },
    { id: 7, question: 'カプセル化の目的は？', answers: ['コード行数削減', 'クラスの内部データを保護', 'プログラム高速化', 'メモリ削減'], correct: 1, explanation: 'カプセル化は private/public などのアクセス修飾子で、クラスの内部データを保護し、不正アクセスを防ぎます。', diagram: 'encapsulation' },
    { id: 8, question: 'ポリモーフィズム（多態性）の利点は？', answers: ['実行速度向上', 'コードの再利用性と拡張性向上', 'メモリ効率', 'セキュリティ向上'], correct: 1, explanation: 'ポリモーフィズムは同じインターフェースで異なる実装を提供し、コードの柔軟性を高めます。', diagram: 'polymorphism' },
    { id: 9, question: 'ガベージコレクション（GC）の役割は？', answers: ['プログラム最適化', '使用されないメモリを自動解放', 'CPU使用率削減', 'ディスク最適化'], correct: 1, explanation: 'ガベージコレクションは自動的に使用されないメモリを検出して解放し、メモリリークを防ぎます。', diagram: 'garbage-collection' },
    { id: 10, question: '関数型プログラミングの特徴として正しいのは？', answers: ['状態変更が頻繁', 'イミュータビリティ（不変性）重視', 'グローバル変数多用', 'サイドエフェクト重視'], correct: 1, explanation: '関数型プログラミングは純粋関数とイミュータビリティを重視し、副作用を最小化します。', diagram: 'functional-programming' },
    { id: 11, question: 'デバッグの際に有効な手法は？', answers: ['全部削除して書き直す', 'ログ出力とブレークポイント', 'プログラムの配布', 'テスト省略'], correct: 1, explanation: 'ログ出力やデバッガを使用したブレークポイント設定はバグ特定に有効です。', diagram: 'debugging' },
    { id: 12, question: 'オーバーロード（多重定義）とオーバーライド（上書き）の違いは？', answers: ['同じ意味', '同じ名前の複数関数 vs 親の関数を子がオーバーライド', '古い機能', 'エラー'], correct: 1, explanation: 'オーバーロードは同じ名前で異なるシグネチャの複数メソッド。オーバーライドは親クラスのメソッドを子クラスで上書き。', diagram: 'overload-vs-override' },
    { id: 13, question: 'ユニットテストの目的は？', answers: ['完全なバグ検出', '個別機能の動作確認', 'ユーザー受け入れテスト', 'パフォーマンス測定'], correct: 1, explanation: 'ユニットテストは最小単位（関数、メソッド）の機能を検証し、早期にバグを検出します。', diagram: 'unit-testing' },
    { id: 14, question: 'コードレビューの主な目的は？', answers: ['チームビルディング', 'コード品質向上とバグ検出', 'プロジェクト計画', 'リリース日程決定'], correct: 1, explanation: 'コードレビューは品質基準を保証し、知識共有を促進し、潜在的なバグや設計問題を早期に発見します。', diagram: 'code-review' },
  ],
  hardware: [
    { id: 1, question: 'キャッシュメモリがCPUとメインメモリの間に配置される理由は？', answers: ['電力消費を削減', '速度の差を埋めるため', 'メモリ容量を増やす', 'セキュリティ向上'], correct: 1, explanation: 'CPUとメインメモリの速度差が大きいため、キャッシュメモリで高速化します。', diagram: 'cpu-cache' },
    { id: 2, question: 'CPUキャッシュの L1, L2, L3 の関係として正しいのは？', answers: ['容量：L1 > L2 > L3', '容量：L3 > L2 > L1', '速度：すべて同じ', 'L2 は使用されない'], correct: 1, explanation: 'L1が最速だが容量が小さく、L3が最大容量。L1>L2>L3の順で速度低下。', diagram: 'cache-hierarchy' },
    { id: 3, question: 'メモリの ECC の機能は？', answers: ['データ圧縮', 'エラー検出・訂正', 'アクセス高速化', 'メモリ容量増加'], correct: 1, explanation: 'ECC（Error Correcting Code）はメモリエラーを検出・訂正し、信頼性を向上させます。', diagram: 'ecc-memory' },
    { id: 4, question: 'SSD と HDD の主な違いは？', answers: ['容量が異なる', '可動部の有無', 'インターフェース型式', 'メーカーの違い'], correct: 1, explanation: 'SSD は可動部がなく高速。HDD は機械的な回転プレートを使用。', diagram: 'ssd-vs-hdd' },
    { id: 5, question: 'マルチコアプロセッサの利点として正しいのは？', answers: ['シングルタスク高速化', 'マルチタスク性能向上', 'クロック周波数向上', 'キャッシュ削減'], correct: 1, explanation: 'マルチコアは複数のタスクを並行処理でき、マルチスレッド応用で性能が向上します。', diagram: 'multicore' },
    { id: 6, question: 'メモリバンド幅の役割は？', answers: ['メモリ容量', 'CPU とメモリ間のデータ転送速度', 'アクセスタイミング', 'キャッシュサイズ'], correct: 1, explanation: 'メモリバンド幅はCPUとメモリ間で1秒あたり転送できるデータ量。高いほど高性能。', diagram: 'memory-bandwidth' },
    { id: 7, question: 'DMA（Direct Memory Access）の役割は？', answers: ['CPU の計算', 'CPU を経由しないI/O データ転送', 'メモリアドレス指定', 'キャッシュ管理'], correct: 1, explanation: 'DMA はCPU を経由せず、I/O デバイスがメモリに直接アクセス。CPU 負荷軽減。', diagram: 'dma' },
    { id: 8, question: 'GPU の用途として正しいのは？', answers: ['CPUの代替', '並列処理（画像処理、AI など）', 'I/O 制御', 'ファイルシステム'], correct: 1, explanation: 'GPU は多数のコアで並列処理に特化。グラフィックス、機械学習などで高速化。', diagram: 'gpu' },
  ],
  system: [
    { id: 1, question: 'プロセスとスレッドの違いは？', answers: ['同じ意味', 'プロセスは独立、スレッドは共有メモリ内実行', 'スレッドのみ実行', 'プロセスより速い'], correct: 1, explanation: 'プロセスは独立したメモリ空間を持つ。スレッドはプロセス内で共有メモリで実行。', diagram: 'process-vs-thread' },
    { id: 2, question: 'コンテキストスイッチの役割は？', answers: ['CPU キャッシュ削除', 'CPU 上で複数プロセスを交互に実行', 'メモリ割り当て', 'ディスク I/O'], correct: 1, explanation: 'コンテキストスイッチで CPU は複数プロセス間を切り替え、マルチタスクを実現。', diagram: 'context-switch' },
    { id: 3, question: 'プロセススケジューラの役割は？', answers: ['メモリ管理', 'CPU 時間をプロセスに割り当て', 'ファイル管理', 'ネットワーク管理'], correct: 1, explanation: 'スケジューラは CPU 時間をプロセスに公平に割り当て、効率的な実行順序を決定。', diagram: 'scheduler' },
    { id: 4, question: '仮想メモリの目的は？', answers: ['メモリ容量増加幻想、ページング機構', 'CPU 高速化', 'ディスク転送', 'ネットワーク接続'], correct: 0, explanation: '仮想メモリはメインメモリより大容量に見えるようにし、物理メモリ不足を補います。', diagram: 'virtual-memory' },
    { id: 5, question: 'ページングとセグメンテーションの違いは？', answers: ['同じ機構', '固定サイズ vs 可変サイズメモリ分割', '順序が違う', 'OS の違い'], correct: 1, explanation: 'ページングは固定サイズ、セグメンテーションは可変サイズで仮想メモリを管理。', diagram: 'paging-vs-segmentation' },
    { id: 6, question: 'ミューテックス（Mutex）の役割は？', answers: ['メモリアクセス', '共有リソースの排他制御', 'CPU スケジューリング', 'キャッシュ管理'], correct: 1, explanation: 'Mutex は複数スレッドが同時にリソースアクセスするのを防ぎ、データ競合を排除。', diagram: 'mutex' },
    { id: 7, question: 'セマフォ（Semaphore）の用途は？', answers: ['メモリ保護', 'リソースカウント管理と同期制御', 'CPU 割り当て', 'ファイルロック'], correct: 1, explanation: 'セマフォはカウンタでリソース数を管理し、複数スレッドのアクセスを制御。', diagram: 'semaphore' },
    { id: 8, question: 'モニタ（Monitor）が提供するもの？', answers: ['CPU 監視', '排他制御と条件変数による同期機構', 'メモリ監視', 'ネットワーク監視'], correct: 1, explanation: 'Monitor は mutex と condition variable を統合し、スレッド間同期を簡潔に実装。', diagram: 'monitor' },
    { id: 9, question: 'ファイルシステムの inode の役割は？', answers: ['ファイル名格納', 'ファイルのメタデータ（権限、サイズなど）管理', 'ディレクトリ', 'キャッシュ'], correct: 1, explanation: 'inode はファイルのメタデータを格納。ファイル名はディレクトリが inode 番号に対応。', diagram: 'inode' },
    { id: 10, question: 'RAID1（ミラーリング）の特徴は？', answers: ['データ圧縮', 'ディスク複製でバックアップ', 'ストライピング', 'パリティ計算'], correct: 1, explanation: 'RAID1 は同一データを複数ディスクに複製。1つディスク故障時もデータ保護。', diagram: 'raid1' },
    { id: 11, question: 'RAID5（ストライピング＋パリティ）の利点は？', answers: ['100% 容量利用', 'パフォーマンス＋冗長性のバランス', '完全なバックアップ', 'CPU 低下'], correct: 1, explanation: 'RAID5 はストライピングで性能向上、パリティで冗長性確保。1ディスク故障対応可能。', diagram: 'raid5' },
  ],
  theory: [
    { id: 1, question: 'シャノンエントロピーの意義は？', answers: ['通信速度', '情報量の尺度', 'エラー率', '圧縮率'], correct: 1, explanation: 'シャノンエントロピーは情報の不確定性を定量化し、情報理論の基礎です。', diagram: 'shannon-entropy' },
    { id: 2, question: 'ハフマン符号化の利点は？', answers: ['高速処理', '最適可変長符号でデータ圧縮', 'エラー訂正', '暗号化'], correct: 1, explanation: 'ハフマン符号化は出現頻度に基づき、短い符号を割り当てることでデータを圧縮。', diagram: 'huffman-coding' },
    { id: 3, question: 'チェックサムの目的は？', answers: ['データ暗号化', 'エラー検出', 'データ圧縮', 'ファイル管理'], correct: 1, explanation: 'チェックサムはデータの各要素を合計し、通信中のエラーを検出。', diagram: 'checksum' },
    { id: 4, question: 'CRC（巡回冗長検査）の特徴は？', answers: ['高い圧縮率', 'バースト誤りに強い', '暗号化機能', 'データ復元'], correct: 1, explanation: 'CRC は多項式演算でバースト誤り検出に強く、データ通信での実用性が高い。', diagram: 'crc' },
    { id: 5, question: 'ハミング距離の意義は？', answers: ['通信速度', 'エラー検出能力の指標', '圧縮率', 'エンコード長'], correct: 1, explanation: 'ハミング距離は2つの符号列が異なるビット数。大きいほどエラー検出能力が高い。', diagram: 'hamming-distance' },
    { id: 6, question: 'ハミング符号の機能として正しいのは？', answers: ['データ圧縮', 'エラー検出・訂正', 'データ暗号化', 'ファイル圧縮'], correct: 1, explanation: 'ハミング符号は余長ビットを追加し、単一ビットエラーを自動訂正可能。', diagram: 'hamming-code' },
    { id: 7, question: 'ベイズの定理の応用例として正しいのは？', answers: ['暗号化', '確率推定とスパムフィルタリング', 'データ圧縮', 'ネットワークルーティング'], correct: 1, explanation: 'ベイズの定理は事前確率から事後確率を計算。スパムフィルタ、医療診断などに応用。', diagram: 'bayes-theorem' },
    { id: 8, question: 'マルコフ連鎖の特性は？', answers: ['決定的', '未来は過去と無関係', '現在の状態のみ依存', '時間逆行'], correct: 2, explanation: 'マルコフ性：未来状態は現在状態のみに依存。過去履歴は関係ない（無記憶性）。', diagram: 'markov-chain' },
    { id: 9, question: 'トラスト・カリキュレーション（信頼度計算）の応用分野は？', answers: ['データベース設計', '推薦システム・信用スコア', 'ネットワーク設計', 'ハードウェア'], correct: 1, explanation: '信頼度計算はユーザーの信用スコア、推薦システムのスコアリングに応用。', diagram: 'trust-score' },
  ],
};
